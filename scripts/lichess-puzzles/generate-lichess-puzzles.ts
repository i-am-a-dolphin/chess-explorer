import { parse } from "csv-parse/sync";
import fs from "fs";
import JSON5 from "json5";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const encodedPath = path.join(__dirname, "lichess-puzzles-encoded.csv");
const mappingPath = path.join(__dirname, "lichess-puzzles-ko-mapping.csv");
const outputPath = path.join(__dirname, "../../__generated/puzzles.ts");

const themeContent = fs.readFileSync(mappingPath, "utf-8");
const themeRecords = parse<Record<string, string>>(themeContent, {
  columns: true,
  skip_empty_lines: true,
  trim: true,
});

const themes = themeRecords.map((record, index) => {
  const { id, theme, theme_en, theme_ko, category_en, category_ko, frequency } =
    record;

  if (!id || !theme || !theme_en || !theme_ko || !category_en || !category_ko) {
    throw new Error(
      `Invalid theme data at line ${index + 2}: missing required fields`,
    );
  }

  return {
    id,
    theme,
    theme_en,
    theme_ko,
    category_en,
    category_ko,
    frequency: parseInt(frequency || "0", 10),
  };
});

type PuzzleTheme = {
  id: string;
  theme: string;
  theme_en: string;
  theme_ko: string;
  category_en: string;
  category_ko: string;
  frequency: number;
};

const encodedContent = fs.readFileSync(encodedPath, "utf-8");
const encodedRecords = parse<Record<string, string>>(encodedContent, {
  columns: true,
  skip_empty_lines: true,
  trim: true,
});

const puzzles = encodedRecords.slice(0, 1000).map((record, index) => {
  const puzzleId = record.id;
  const themesStr = record.themes;

  if (!puzzleId || !themesStr) {
    throw new Error(
      `Invalid puzzle data at line ${index + 2}: missing required fields`,
    );
  }

  return {
    puzzleId,
    themes: themesStr,
  };
});

// Group themes by category
const themesByCategory = new Map<string, PuzzleTheme[]>();
themes.forEach((theme) => {
  const key = `${theme.category_en}|${theme.category_ko}`;
  if (!themesByCategory.has(key)) {
    themesByCategory.set(key, []);
  }
  themesByCategory.get(key)!.push(theme);
});

// Convert to array format for output
const themesCategorized = Array.from(themesByCategory.entries()).map(
  ([key, categoryThemes]) => {
    const [categoryEn, categoryKo] = key.split("|");
    return {
      categoryEn,
      categoryKo,
      themes: categoryThemes,
    };
  },
);

const tsContent = `// @ts-nocheck
// This file is generated by scripts/lichess-puzzles/generate-lichess-puzzles.ts
// Do not edit this file manually

export type Puzzle = {
  puzzleId: string;
  themes: string;
};

export type PuzzleTheme = {
  id: string;
  theme: string;
  theme_en: string;
  theme_ko: string;
  category_en: string;
  category_ko: string;
  frequency: number;
};

export type PuzzleThemeByCategory = {
  categoryEn: string;
  categoryKo: string;
  themes: PuzzleTheme[];
};

export const PUZZLES = ${JSON5.stringify(puzzles)} as const;

export const PUZZLE_THEMES = ${JSON5.stringify(themes)} as const;

export const PUZZLE_THEMES_BY_CATEGORY = ${JSON5.stringify(themesCategorized)} as const;\n`;

const outputDir = path.dirname(outputPath);
fs.mkdirSync(outputDir, { recursive: true });
fs.writeFileSync(outputPath, tsContent);

console.log(
  `Generated __generated/puzzles.ts (${puzzles.length} puzzles, ${themes.length} themes)`,
);
